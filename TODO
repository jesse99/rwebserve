Built with: 1eae49748d55367e7e70005b03ac2261b36122c9

REST in Practice
RESTful Web Services
RESTful Web Services Cookbook

tcpdump -i lo0 -w packets.pcap tcp


* Log client ip, method, url
* Disallow requests where the request path has a component enclosed in parens:
	- but what about relative URLs? even when they are relative the browser generates an abs path 
* Need a way for users to generate URLs:
	- also need to encode them if they have bad chars
* Need to include a date header. Think that there is a std::time now.
* Work on http support:
	- connection close means the connection should close, 8.1.2.1
	- timeout connections
	- handle continue, 8.2.3
	- methods are documented in 9.0
	- accept-language
	- status 300
	- 13.2.1 says expiration may be in the past
	- should headers be typed?
	- 14.1 has headers
* Caching
	- chapter 6 has good info
* Add default css handler.
* Tween support could be cool.
* Make sure examples are well commented.
* Look at some python or haskell web servers.
* Look at:
	- hal, rest-style json: http://stateless.co/hal_specification.html
* Work on restbucks example.
* Talk about architecture.
* Servers need to handle Connection: close in requests

* Allow for multiple roots.

/Users/jessejones/Documents/Developer/rust.rtf
/Users/jessejones/Documents/Developer/web.rtf
http://www.w3schools.com/html5/html5_reference.asp
http://reference.sitepoint.com/html/img
http://htmldog.com/reference/htmltags/


request: GET / HTTP/1.1\r\n
Host: localhost:8080\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:11.0) Gecko/20100101 Firefox/11.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip, deflate\r\n
Connection: keep-alive\r\n
\r\n


REST		http://kellabyte.com/2011/09/04/clarifying-rest/    http://codebetter.com/glennblock/2011/05/09/hypermedia-and-forms/
1) Each request from the client to the server must contain all of the data that is necessary to handle the request
2) The data within a response to a request must be implicitly or explicitly labeled as cacheable or non-cacheable
3) Each layer cannot see beyond the immediate layer with which it is communicating with
4) Uniform interface
4a) Each resource has a URI and is access through a defined set of HTTP methods (GET, PUT, POST, DELETE)
4b) Each resource can have one or more representations. Such as application/xml, application/json, text/html, etc
4c) Self-descriptive messages: Requests and responses contain not only data but additional headers describing how the content should be handled
4d) Hypermedia as the engine for application state

A REST API must not define fixed resource names or hierarchies (an obvious coupling
of client and server). Servers must have the freedom to control their own namespace. 
Instead, allow servers to instruct clients on how to construct appropriate URIs, such 
as is done in HTML forms and URI templates, by defining those instructions within 
media types and link relations. [Failure here implies that clients are assuming a 
resource structure due to out-of band information, such as a domain-specific 
standard, which is the data-oriented equivalent to RPC's functional coupling].
